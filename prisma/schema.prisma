// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

/**
 * ---------------- Enums ----------------
 */
enum DominantFoot {
  L
  R
  B
  N
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
  EXPIRED
}

enum AccessStatus {
  PENDING
  APPROVED
  DECLINED
}

enum MatchStatus {
  DRAFT
  OPEN
  CLOSED
}


/**
 * ---------------- Modeller ----------------
 */

model User {
  id                 String       @id @default(cuid())
  phone              String       @unique
  dominantFoot       DominantFoot @default(N)
  positions          Json
  positionLevels     Json?
  availability       Json?
  preferredFormation String?
  level              Int          @default(5)

  // keşif
  lat          Float?
  lng          Float?
  discoverable Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ratings
  ratingsGiven    Rating[] @relation("Rater")
  ratingsReceived Rating[] @relation("Rated")

  behaviorRollup BehaviorRollup?

  posRatingsGiven    PositionRating[] @relation("PosRater")
  posRatingsReceived PositionRating[] @relation("PosRated")

  // Arkadaşlık
  sentFriendRequests     FriendRequest[] @relation("FriendRequestFrom")
  receivedFriendRequests FriendRequest[] @relation("FriendRequestTo")

  userFriends Friendship[] @relation("UserFriends")
  friendsOf   Friendship[] @relation("UserFriendsOf")

  // Back-relations
  Message Message[] // -> Message.user
  Match   Match[] // -> Match.owner

  // Davetler
  invitesSent     MatchInvite[] @relation("InviteFromUser")
  invitesReceived MatchInvite[] @relation("InviteToUser")

  // Erişim isteği: bu kullanıcının açtıkları
  accessRequestsSent MatchAccessRequest[] @relation("AccessRequestsFromUser")

  @@index([lat, lng])
}

model FriendRequest {
  id        String              @id @default(cuid())
  fromId    String
  toId      String
  status    FriendRequestStatus @default(PENDING)
  message   String?
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt

  from User @relation("FriendRequestFrom", fields: [fromId], references: [id], onDelete: Cascade)
  to   User @relation("FriendRequestTo", fields: [toId], references: [id], onDelete: Cascade)

  @@unique([fromId, toId])
  @@index([toId])
  @@index([fromId])
}

model Friendship {
  id        String   @id @default(cuid())
  userId    String
  friendId  String
  createdAt DateTime @default(now())

  user   User @relation("UserFriends", fields: [userId], references: [id], onDelete: Cascade)
  friend User @relation("UserFriendsOf", fields: [friendId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
  @@index([friendId])
  @@index([userId])
}

model Message {
  id      String @id @default(cuid())
  matchId String
  match   Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)
  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  text    String

  deleted   Boolean   @default(false)
  editedAt  DateTime?
  updatedAt DateTime  @updatedAt

  createdAt DateTime @default(now())
}

model MatchAccessRequest {
  id          String       @id @default(cuid())
  matchId     String
  requesterId String
  status      AccessStatus @default(PENDING)
  message     String?
  createdAt   DateTime     @default(now())
  respondedAt DateTime?

  // Karşı alanlarla relation isimlerini eşleştir
  match     Match @relation("MatchAccessRequests", fields: [matchId], references: [id], onDelete: Cascade)
  requester User  @relation("AccessRequestsFromUser", fields: [requesterId], references: [id], onDelete: Cascade)

  @@unique([matchId, requesterId], map: "uniq_access_req")
  @@index([matchId])
  @@index([requesterId])
}

model Match {
  id       String   @id @default(cuid())
  title    String
  location String?
  level    String   @default("Orta")
  format   String   @default("7v7")
  price    Int?
  time     DateTime @default(now())
  slots    Json     @default("[]")
  ownerId  String?
  owner    User?    @relation(fields: [ownerId], references: [id])

  status    MatchStatus  @default(OPEN)   
  closedAt  DateTime?                    

  ratings Rating[]

  inviteOnly Boolean @default(false)

  // back-relations
  invites    MatchInvite[]
  messages   Message[]
  posRatings PositionRating[]

  // Erişim istekleri (karşı: MatchAccessRequest.match)
  accessRequests MatchAccessRequest[] @relation("MatchAccessRequests")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model MatchInvite {
  id          String       @id @default(cuid())
  matchId     String
  fromUserId  String
  toUserId    String?
  toPhone     String?
  message     String?
  status      InviteStatus @default(PENDING)
  expiresAt   DateTime?
  respondedAt DateTime?
  createdAt   DateTime     @default(now())

  match    Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  fromUser User  @relation("InviteFromUser", fields: [fromUserId], references: [id])
  toUser   User? @relation("InviteToUser", fields: [toUserId], references: [id])

  @@index([matchId])
  @@index([toUserId])
  @@index([toPhone])
}

model Rating {
  id      String @id @default(cuid())
  matchId String
  raterId String
  ratedId String

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  rater User  @relation("Rater", fields: [raterId], references: [id], onDelete: Cascade)
  rated User  @relation("Rated", fields: [ratedId], references: [id], onDelete: Cascade)

  traits    Json
  weight    Float     @default(1.0)
  editCount Int       @default(1)
  lockedAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([matchId, raterId, ratedId])
  @@index([ratedId])
  @@index([raterId])
  @@index([matchId])
}

model BehaviorRollup {
  userId String @id
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  samples    Int      @default(0)
  punctual   Float    @default(0)
  respect    Float    @default(0)
  sports     Float    @default(0)
  swearing   Float    @default(0)
  aggression Float    @default(0)
  wsum       Float    @default(0)
  si         Float    @default(0)
  updatedAt  DateTime @updatedAt
}

model PositionRating {
  id      String @id @default(cuid())
  matchId String
  raterId String
  rateeId String
  pos     String // 'GK','LB','CB',...
  score   Float // 1..10
  weight  Float  @default(1.0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  rater User  @relation("PosRater", fields: [raterId], references: [id], onDelete: Cascade)
  ratee User  @relation("PosRated", fields: [rateeId], references: [id], onDelete: Cascade)

  @@unique([matchId, raterId, rateeId, pos])
  @@index([rateeId, pos])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String   // 'access_approved' | 'rating_reminder' | ...
  matchId   String?
  data      Json?
  createdAt DateTime @default(now())
  readAt    DateTime?

  @@index([userId, readAt])
  @@index([userId, type])
  @@unique([userId, type, matchId]) // aynı kullanıcı+tip+maç için tekrarı engelle
}
